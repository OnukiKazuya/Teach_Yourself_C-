レガシーコードからの脱去

■ウォーターホールのデメリット
	建築などでは、一回家を立てたら変更することがないため、ウォーターホールが望ましい。
	そもそも、何百年と経て建築ではウォータフォールが確立した。
	しかし、ソフトウェアのアーキテクトでは、まだソフトウェアができて数十年のため
	建築と同じウォーターフォールが適しているとは限らない。
	実際に、建築とは違う箇所でソフトウェアを開発してからアップデートを行う。
	これは、一回家を建てた後に、家をリフォームするということ。
	そんなものは明らかに、向いていないとわかる。

■ソフトウェア開発ではどのように開発していけば良いか
	まず、ソフトウェアが時間と共に変化していくことを理解する。
	そのため、改変しやすいコードを書く必要がある

■改変しやすいコードを書くには
	９つのプラクティス
	・やり方より先に目的、理由、誰のためか伝える
	・小さなバッチを作る
	・継続的に統合する
	・「CLEAN」コードを作る
	・まずテストを書く
	・テストで振る舞いを明示する
	・設計は最後に行う
	・レガシーコードをリファクタリングする

■単一責務の原則
	クラスを変更する理由は１つでなければならない
	
■やり方より先に目的、理由、誰のためか伝える
	・ソフトウェア開発者なら、抽象→具体化また逆も上手にできなくてはならない
	・ユースケースや仕様書ではなくストーリを考える。ストーリは出発点にすぎない
	・ストーリは機能がどうやるかではなく、何をするかに焦点を当てる
	→設計の改善につながる
	・シンプルに始めて、追加は後
	・ストーリは要求仕様書などとは根本的に違う、その機能の目指すところが何で、なぜ、誰のためなのかが最低限の説明で表される。

■小さなバッチで作る
	・小さなバッチで作るということは、想定ではなく検証を続けるということ
	・基地のことと道のことを分離する

■継続的インテグレーション（コードの変更を(中央の)リポジトリに頻繁にマージし、かつ「定期的・自動的」に「ビルド・テスト」を行うという手法）
●アジャイルインフラストラクチャー	
	・使用しているもの全てをversion管理をする
	・ビルドPCを立てる、そして心臓と同じように常にビルドできる環境を構築する
	・ビルドを自動化する
	・早期から頻繁に結合する（１日一回は結合）
	・テストカバレッジを維持する→テスト駆動開発を行い、100%網羅できるようにする、
	・テスト可能なコードを書く→QAの会期テストの時間を減らすだけでなく、開発者が自分のアプローチがうまくいきそうかフィードバックを得られるようになる
	・タスクの受け入れ基準を作る→SpecFlow,FIT,Cucumberなどのテストフレームワークを使う
●リスクを減らす７つの戦略
	・継続的に結合
	・ブランチを避ける
	・自動テストに投資する→テストの自動化が難しいコードなら書き直す
	・リスクある場所を特定する
	・未知の中で動く→未知のものがあったら、短時間だけそれに取り組み、記録して進捗を確認する。
	・価値がわかるもの最小のものを作る→問題が小さいほど理解、解決、証明、保守が容易。価値がわかる最小のもの。８割の価値が２割の機能からきている場合はその２割から作る
	・頻繁に検証する→

■協力し合う
	・設計レビューやコードレビューでは、まず設計とその設計を選択した理由について討論すべき
	・

■CLEANコードを作る
	・Cohesive（凝縮性）, LooselyCoupled（疎結合）, Encapsulated（カプセル化）, Assertive（断定的）, Nonredundant（非冗長）

	・Cohesive（凝縮性）：ソフトウェアのエンティティ（クラス、メソッド）は単一の責任を持つべきである
	・LooselyCoupled（疎結合）：オブジェクト間の関係を明確な意図を持った状態に保つこと。のエンティティ間の副作用がへる。
	　間接的にしか依存しないことで分離、検証、再利用、拡張が容易になる。
	例えば抽象クラスのような抽象階層を経由して呼び出す。インターフェースを使用する。テスト際にモックを使ってサービスを置き換える。　
	・Encapsulated（カプセル化）：変更がシステムに及ぼす「波及効果」を減らす。複雑さを管理し、呼び出し元が呼び出し先の実装の詳細を知らなくても良いように維持できる。
 	・Assertive（断定的）：ふるまいを配置する場所は、多くの場合は依存データがある場所であることをしましている
	・Nonredundant（非冗長）：バグの修正や変更を１箇所で１回だけやればよくなる。ミッションクリティカルの場合はわざと冗長性を持たせることはある。

	・あるクラスのテストをたくさん書く→凝縮性の問題
	・関係ない依存関係がたくさんある→結合の問題
	・テストが実装に依存している→カプセル化の問題
	・テストの結果がテストしているオブジェクト以外から得られる→断定性の問題
	・あちこちで同じテストを書く→冗長性の問題
	↔️テストのしやすさが設計や実装の品質を計測する基準になる


	◎ペアプロ、頻繁にコードレビュー、他の開発者のやり方を学ぶ、ソフトウェア開発を学ぶ、コードを読み書きしてコーディングの練習をする
	gitなどで人のコードを見る、本を沢山読んでソフトウェア開発を学ぶ、読んで書きまくる

■まずテストを書く
	・テストは仕様であり、ふるまいを定義する
	・テストを自動化する
	・受け入れテスト＝顧客テスト：Gherkinと呼ばれる言語（受け入れテストのツールに実装される）ものがある
	・ユニットスト＝開発者によるテスト
	・それ以外のテスト＝QAテスト
	・テストファーストは仮設を書くと思え。要件を理解しているという仮設。
	・ユニットとは、メソッド、クラス、モジュール、関数などのエンティティではなくふるまいの単位
	・まずはテストに失敗するテストを書く。→書かれた全てのコードがテストでカバーされていることを保証する

■テストでふるまいを明示する
	・テストファーストにすることでふるまいを明示していく
	・テストファーストには３つのフェーズが存在する
	レッド、グリーン、リファクタリング
	流れ　テストを書く、スタブアウト、テスト実行、実装を小さい単位で行う
	・ユニットテストは仕様
	・良いテストの基準：未知の理由ではなく、既知の理由で失敗することと、その既知の理由で失敗するテストはシステム内で１つだけであること
	→テストは一意である
	・モックとは、実際のオブジェクトの代役
	・セーフティーネットを作る：テストファーストにすることでテストしやすいコードを書くようになり、維持するコストも抑えられる。ユニットテストをコードに組みこむこと
	→最後に設計する

■設計は最後に行う
	・コードが全て書かれていて、テストでサポートされてい状態が、ソフトウェアの保守性を設計をするのに最適なタイミング
	・循環複雑度を減らす：ポリモーフィズムを用いる→オブジェクトを使う際の条件分岐をオブジェクトの生成のタイミングに移せる
	・オブジェクト指向設計の理解、デザインパターンの理解、テスト駆動開発を理解、リファクタリングを理解
	・テストを足すために接合部を作る：レガシーコードは絡み合っていてテストすべき部分の分離が難しい、そこで接合部を設ける
	・メソッドの抽出、クラスの抽出：理想的なメソッドは４行を超えない→メソッドの凝縮性を高める
	・プロセスのルールを集約

■レガシーーコードをリファクタリングする
	・レガシーコードは時限爆弾ではなく地雷→変更がない場合は放置
	・レガシーコードをリファクタリングする場合は、ユニットテスト（セーフティネット）を作ってからリファクタリングすることで安全を確保
	テクニック
	・ピンニングテスト：粗いテスト。まずはふるまいだけをテスト、そして徐々に小さくしていきユニットテストとしていく
	・依存性の注入：依存関係を注入することで、サービスから切り離される→ソフトウェアはテスト可能になり拡張しやすくなる
	・ストラングラーパターン：システムを停止せずコンポーネントを変更する場合に使用する。
						ゆっくり置き換えるということ。新しいインターフェースを作り、レガシーコード側のインターフェイスを削除する
	・抽象化に夜ブランチ：version管理からブランチをなくすのに役立つ。変更したいコードからインターフェイスを抽出して、新しい実装を書く
					新しい実装を開発している間は古い実装をそのまま使い、開発中の機能を隠すためにフューチャフラグを使用する